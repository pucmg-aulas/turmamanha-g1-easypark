package UnitaryTests;

import Controllers.RelatorioFrequenciaUsoVagaController;
import dao.PagamentobdDAO;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import java.io.IOException;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import view.RelatorioFrequenciaUsoVagaView;


import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class RelatorioFrequenciaUsoVagaControllerTest {

    private JDesktopPane desktopPane;
    private RelatorioFrequenciaUsoVagaView viewMock;
    private PagamentobdDAO pagamentosMockDAO;
    private RelatorioFrequenciaUsoVagaController controller;
    private final int idEstacionamento = 1;

    @BeforeEach
    public void setUp() throws SQLException, IOException {
        desktopPane = mock(JDesktopPane.class);
        viewMock = mock(RelatorioFrequenciaUsoVagaView.class);
        pagamentosMockDAO = mock(PagamentobdDAO.class);

        // Configura o mock da view para retornar componentes simulados
        when(viewMock.getTabela()).thenReturn(new JTable());
        when(viewMock.getTabela().getModel()).thenReturn(new DefaultTableModel());

        // Cria o controller usando os mocks
        controller = new RelatorioFrequenciaUsoVagaController(desktopPane, idEstacionamento);
    }

    @Test
    public void testCarregarTabela() throws SQLException {
        // Configura os dados simulados para arrecadação e tempo
        Map<String, Map<String, Double>> arrecadacaoETempoMock = new HashMap<>();
        Map<String, Double> dadosTipoAVaga = new HashMap<>();
        dadosTipoAVaga.put("FaturamentoMedioPorUso", 1500.00);
        dadosTipoAVaga.put("TempoMedioOcupacao", 120.5);
        arrecadacaoETempoMock.put("Tipo A", dadosTipoAVaga);

        Map<String, Double> dadosTipoBVaga = new HashMap<>();
        dadosTipoBVaga.put("FaturamentoMedioPorUso", 800.75);
        dadosTipoBVaga.put("TempoMedioOcupacao", 95.0);
        arrecadacaoETempoMock.put("Tipo B", dadosTipoBVaga);

        // Configura o mock do DAO para retornar os dados simulados
        when(pagamentosMockDAO.buscarTempoMedioEOcupacao(idEstacionamento)).thenReturn(arrecadacaoETempoMock);

        // Executa o método
        controller.carregarTabela();

        // Verifica se a tabela foi preenchida com os dados simulados
        DefaultTableModel tableModel = (DefaultTableModel) viewMock.getTabela().getModel();
        assertEquals(2, tableModel.getRowCount());
        assertEquals("Tipo A", tableModel.getValueAt(0, 0));
        assertEquals("1500.00", tableModel.getValueAt(0, 1));
        assertEquals("120.50", tableModel.getValueAt(0, 2));
        assertEquals("Tipo B", tableModel.getValueAt(1, 0));
        assertEquals("800.75", tableModel.getValueAt(1, 1));
        assertEquals("95.00", tableModel.getValueAt(1, 2));
    }

    @Test
    public void testCarregarTabelaComErro() throws SQLException {
        // Configura o mock para lançar uma exceção
        when(pagamentosMockDAO.buscarTempoMedioEOcupacao(idEstacionamento)).thenThrow(new SQLException("Erro ao acessar o banco de dados"));

        // Executa o método e verifica se ele lida com a exceção
        try {
            controller.carregarTabela();
            fail("Deveria ter lançado uma SQLException");
        } catch (SQLException e) {
            assertEquals("Erro ao acessar o banco de dados", e.getMessage());
        }
    }
}
